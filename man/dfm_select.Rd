% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dfm_select.R, R/fcm-methods.R
\name{dfm_select}
\alias{dfm_select}
\alias{dfm_remove}
\alias{dfm_keep}
\alias{fcm_select}
\alias{fcm_remove}
\alias{fcm_keep}
\title{Select features from a dfm or fcm}
\usage{
dfm_select(x, pattern = NULL, selection = c("keep", "remove"),
  valuetype = c("glob", "regex", "fixed"), case_insensitive = TRUE,
  min_nchar = 1L, max_nchar = 79L, verbose = quanteda_options("verbose"))

dfm_remove(x, ...)

dfm_keep(x, ...)

fcm_select(x, pattern = NULL, selection = c("keep", "remove"),
  valuetype = c("glob", "regex", "fixed"), case_insensitive = TRUE,
  verbose = quanteda_options("verbose"), ...)

fcm_remove(x, pattern = NULL, ...)

fcm_keep(x, pattern = NULL, ...)
}
\arguments{
\item{x}{the \link{dfm} or \link{fcm} object whose features will be selected}

\item{pattern}{a character vector, list of character vectors, \link{dictionary},
\link{collocations}, or \link{dfm}. See \link{pattern} for details.}

\item{selection}{whether to \code{keep} or \code{remove} the features}

\item{valuetype}{the type of pattern matching: \code{"glob"} for "glob"-style
  wildcard expressions; \code{"regex"} for regular expressions; or
  \code{"fixed"} for exact matching. See \link{valuetype} for details.

  For \code{dfm_select}, \code{pattern} may also be a \link{dfm}; see Value
  below.}

\item{case_insensitive}{ignore the case of dictionary values if \code{TRUE}}

\item{min_nchar, max_nchar}{numerics specifying the minimum and maximum length
in characters for features to be removed or kept; defaults are 1 and
\href{https://en.wikipedia.org/wiki/Donaudampfschiffahrtselektrizit√§tenhauptbetriebswerkbauunterbeamtengesellschaft}{79}.
 (Set \code{max_nchar} to \code{NULL} for no upper limit.) These are
applied after (and hence, in addition to) any selection based on pattern
matches.}

\item{verbose}{if \code{TRUE} print message about how many pattern were
removed}

\item{...}{used only for passing arguments from \code{dfm_remove} or
\code{dfm_keep} to \code{dfm_select}. Cannot include
\code{selection}.}
}
\value{
A \link{dfm} or \link{fcm} object, after the feature selection has
  been applied.

  When \code{pattern} is a \link{dfm} object and \code{selection = "keep"}, then the returned object will
  be identical in its feature set to the dfm supplied as the \code{pattern}
  argument. This means that any features in \code{x} not in the dfm provided
  as \code{pattern} will be discarded, and that any features in found in the
  dfm supplied as \code{pattern} but not found in \code{x} will be added with
  all zero counts.  Because selecting on a dfm is designed to produce a
  selected dfm with an exact feature match, when \code{pattern} is a
  \link{dfm} object, then the following settings are always used:
  \code{case_insensitive = FALSE}, and \code{valuetype = "fixed"}.
  
  Selecting on a \link{dfm} is useful when you have trained a model on one
  dfm, and need to project this onto a test set whose features must be
  identical.  It is also used in \code{\link{bootstrap_dfm}}.  See examples.

  When \code{pattern} is a \link{dfm} object and \code{selection = "keep"},
  the returned object will simply be the dfm without the featnames matching
  those of the selection dfm.
}
\description{
This function selects or removes features from a \link{dfm} or \link{fcm},
based on feature name matches with \code{pattern}.  The most common usages
are to eliminate features from a dfm already constructed, such as stopwords,
or to select only terms of interest from a dictionary.
}
\details{
\code{dfm_remove} and \code{fcm_remove} are simply a convenience
  wrappers to calling \code{dfm_select} and \code{fcm_select} with
  \code{selection = "remove"}.

  \code{dfm_keep} and \code{fcm_keep} are simply a convenience wrappers to
  calling \code{dfm_select} and \code{fcm_select} with \code{selection =
  "keep"}.
}
\note{
This function selects features based on their labels.  To select
  features based on the values of the document-feature matrix, use
  \code{\link{dfm_trim}}.
}
\examples{
my_dfm <- dfm(c("My Christmas was ruined by your opposition tax plan.",
               "Does the United_States or Sweden have more progressive taxation?"),
             tolower = FALSE, verbose = FALSE)
my_dict <- dictionary(list(countries = c("United_States", "Sweden", "France"),
                          wordsEndingInY = c("by", "my"),
                          notintext = "blahblah"))
dfm_select(my_dfm, my_dict)
dfm_select(my_dfm, my_dict, case_insensitive = FALSE)
dfm_select(my_dfm, c("s$", ".y"), selection = "keep", valuetype = "regex")
dfm_select(my_dfm, c("s$", ".y"), selection = "remove", valuetype = "regex")
dfm_select(my_dfm, stopwords("english"), selection = "keep", valuetype = "fixed")
dfm_select(my_dfm, stopwords("english"), selection = "remove", valuetype = "fixed")

# select based on character length
dfm_select(my_dfm, min_nchar = 5)

# selecting on a dfm
txts <- c("This is text one", "The second text", "This is text three")
(dfm1 <- dfm(txts[1:2]))
(dfm2 <- dfm(txts[2:3]))
(dfm3 <- dfm_select(dfm1, dfm2, valuetype = "fixed", verbose = TRUE))
setequal(featnames(dfm2), featnames(dfm3))

tmpdfm <- dfm(c("This is a document with lots of stopwords.",
                "No if, and, or but about it: lots of stopwords."),
              verbose = FALSE)
tmpdfm
dfm_remove(tmpdfm, stopwords("english"))
toks <- tokens(c("this contains lots of stopwords",
                 "no if, and, or but about it: lots"),
               remove_punct = TRUE)
tmpfcm <- fcm(toks)
tmpfcm
fcm_remove(tmpfcm, stopwords("english"))
}
\keyword{dfm}
