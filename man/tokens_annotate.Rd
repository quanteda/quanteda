% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tokens_annotate.R
\name{tokens_annotate}
\alias{tokens_annotate}
\title{Annotate a tokens object using a dictionary}
\usage{
tokens_annotate(
  x,
  dictionary,
  levels = 1:5,
  valuetype = c("glob", "regex", "fixed"),
  case_insensitive = TRUE,
  marker = "#",
  capkeys = TRUE,
  nested_scope = c("key", "dictionary"),
  apply_if = NULL,
  verbose = quanteda_options("verbose")
)
}
\arguments{
\item{x}{the \link{tokens} object to which the dictionary will be applied}

\item{dictionary}{the \link{dictionary}-class object that will be applied to
\code{x}}

\item{levels}{integers specifying the levels of entries in a hierarchical
dictionary that will be applied.  The top level is 1, and subsequent levels
describe lower nesting levels.  Values may be combined, even if these
levels are not contiguous, e.g. \code{levels = c(1:3)} will collapse the second
level into the first, but record the third level (if present) collapsed
below the first (see examples).}

\item{valuetype}{the type of pattern matching: \code{"glob"} for "glob"-style
wildcard expressions; \code{"regex"} for regular expressions; or \code{"fixed"} for
exact matching. See \link{valuetype} for details.}

\item{case_insensitive}{logical; if \code{TRUE}, ignore case when matching a
\code{pattern} or \link{dictionary} values}

\item{marker}{characters that are added before and after the dictionary keys.}

\item{capkeys}{if \code{TRUE}, convert dictionary keys to uppercase to distinguish
them from unmatched tokens.}

\item{nested_scope}{how to treat matches from different dictionary keys that
are nested.  When one value is nested within another, such as "a b" being
nested within "a b c", then \code{tokens_lookup()} will match the longer.  When
\code{nested_scope = "key"}, this longer-match priority is applied only
within the key, while \code{"dictionary"} applies it across keys, matching only
the key with the longer pattern, not the matches nested within that longer
pattern from other keys.  See Details.}

\item{apply_if}{logical vector of length \code{ndoc(x)}; documents are modified
only when corresponding values are \code{TRUE}, others are left unchanged.}

\item{verbose}{if \code{TRUE} print the number of tokens and documents before and
after the function is applied. The number of tokens does not include paddings.}
}
\description{
Insert dictionary keys as tags in a tokens object where the dictionary patterns are found.
}
\examples{
txt <- c(d1 = "The United States has the Atlantic Ocean and the Pacific Ocean.",
         d2 = "Britain and Ireland have the Irish Sea and the English Channel.")
toks <- tokens(txt)
dict <- dictionary(list(US = list(Countries = c("States"),
                                  oceans = c("Atlantic", "Pacific")),
                        Europe = list(Countries = c("Britain", "Ireland"),
                                      oceans = list(west = "Irish Sea",
                                                    east = "English Channel"))))
tokens_annotate(toks, dict)

}
\seealso{
tokens_lookup
}
\keyword{tokens}
